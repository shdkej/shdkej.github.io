---
title   : 개발 단상
summary :
date    : 2020-11-11 15:55:34 +0100
updated : 2022-08-13 19:09:43 +0900
tags    : develop
---

## [[컴퓨터]]
## [[글쓰기]]
## [[공부]]
## [[알고리즘]]
## [[추상화]]
## [[모듈]]
## [[VS]]
## [[개발]]
## [[정리]]
## [[Regacy]]
## [[사람]]
## [[기본]]

#### 해피 패쓰만 생각하지 않기
- 나보다 똑똑한 사람들이 만들어내는 예외상황이 생긴다
바운더리(경계선) 예외처리 확인 반드시 해야한다.

#### 페어 프로그래밍
짝 코딩을 하면 딴짓을 못하기 때문에 하루 8시간 중 7시간을 코딩과 업무 분석에 집중할 수 있었다.
. 핵심은 쉬지 않고 계속 말을 하는 것. 심지어`int i = 0`이런 걸 쓸 때에도 계속 말하는 것이 핵심이다. 그냥 코딩만 해서는 의도 전달 효율이 매우 낮다. 말하면서 타이핑해야 하고 설명하면서 코딩해야 한다.
짝에게 계속 생각을 노출해야 한다.

#### 이미 나와있는 기술은 써먹으면 된다
근데 FC의 기술은 분석하고자 한다
분류가 다른가? FC를 분석하려는 목적, 종착지는 어디인가

#### 코드 줄 수가 적을수록 관리할 포인트가 줄어든다
1000페이지의 코드보다는 100페이지의 코드가 관리하기 쉽다
하지만 압축적이고 은밀한 코드를 남발하는 것보다는 풀어 쓰는 편이 낫다
추상화를 잘 쓰면 좋지만 난독화가 되지 않아야 한다
의미가 감추어지면 안된다
추상화 속에 전제조건이나 종속성이 숨을 수 있겠다
테스트코드를 먼저 적고 테스트 코드만 통과할 정도의 함수만 작성하고 문제가 생기면
추가하는 방식으로 한다

#### 다양하지만 넘치지 않는 함수
다양한 케이스를 커버할 정도로 추상화시켜야 하지만 요구받지 않은 사항까지
예상해서 만들면 안된다

한 함수가 여러 상황은 커버하지만
당장은 필요없는 함수는 만들 필요 없다라고 하면 좀 쉽네

제네릭 프로그래밍과 정적 타입 언어가 동적 언어와 비슷한 걸 하려는 것 같다

#### 세부적인 개발
예를들어 ejs에서 html로 렌더링 하는 방법 같은 것은 아주 구체적인 부분이지만 딱
그 영역에만 쓰이고, 기억에서도 금방 사라진다.
그래서 구체적인 개발은 하다보면 되는거고 구조를 생각하는게 더 낫겠다고 생각해서
지금의 공부를 하게 되었는데,

이는 경험을 무시하는 것이 되었다.
경험이라는 것이 그 분야를 익히는데에 성장을 많이 시켜주는데 세부적인 것은 까먹더라도 뭔가 남는다.

한 곳을 깊게 파면 경험이 남는다
근데 그 경험을 잘 남기는 방법도 생각해야겠다. 그냥 구현에 급급하면 경험마저 날아간다.

#### 작업 처리라는게 이전에 8시간 만에 되었다고 다음에도 8시간에 되는 것이 아니다
7시간 동안 생각하다가 1시간만에 구현되도 8시간이고, 1시간 생각 후 2시간 동안
구현하다가 망해서 다시 3시간 생각하고 3시간 구현을 다시 해야 할 수도 있다.

업무에 분명히 데드라인이 있으면 해결의지가 강해져서 완수될 가능성은 높아지지만
안풀려서 데드라인 앞에서 급하게 정리한다고 적당히 수습해야 할 때도 있다

적당히 수습을 잘하는 것이 능력일까? 데드라인을 잘 설정하는 것이 능력일까?
둘 다 능력이 아니고 맞춰나가는 것이다.

마무리는 없으니 짧은 단계를 순환시켜서 계속 발전시키는 방향으로 가면 좋겠다

공수에 맞추지 말고 사이클 마감 시간의 기준으로 설정하면 되겠다
8시간 공수면 한 사이클에 끝날수도 있고 3 사이클을 돌릴 수도 있고.

일정 산출 기준을 이전 작업으로 잡고 할 수도, 내 기준으로 할 수도.

-----------------------------------------------------------------------

#### 먼거리에 이동 속도가 가장 빠른 비행기.
프랑스에서는 가까운 거리에서는 비행기 이동을 금지하게 되었다
기술 발전이 인간을 이롭게 하지만, 기후에 안좋은 영향을 미치지 않도록 신경써야한다
소프트웨어에서 탄소배출은 어떤 관계가 있을까
전기를 소모한다.
저전력 머신에서 돌아가면 될까
저전력을 많이 만들면 총 사용량은 비슷할건데
한 서비스가 쓰는 리소스를 줄이면 한 피씨에 사용되는 서비스가 많아질 수 있다

#### code design
main - 메인에서 동작만 나타낸다. 구현은 다른 파일에서 한다
```
func main() {
  init()
  get()
  set()
  health()
  doSomething()
}
```
http_server - http로 렌더링하는 작업만 수행한다
logic - 인터페이스를 받아서 인터페이스를 구현한다
```
type s struct {

}
func (s struct) init() {

}
```

메인은 전체 흐름
에러 처리는 내부에서 처리?
메인 파일은 의미가 있어야 하고, 세부 구현은 적지 않도록...
```
func main() {
    if err := initHTTPServer(); err != nil { log.Println(err) }
    if err = addHealthCheck(); err != nil { log.Println(err) }
    if err = addLogic(); err != nil { log.Println(err) }
    if err = addLoggig(); err != nil { log.Println(err) }
    if err = runHTTPServer(); err != nil { log.Println(err) }
}
```

#### 피드백 소프트웨어
api 서버에서는 원하는 요청에 대해 기대하는 결과값을 설정해두고,
피드백 소프트웨어에서 확인하여 원하는 결과값이 안나오면 조절해주는 방식을
구현해보자

#### if statement
긍정을 먼저 쓴다?
뒤에 고정값을 둔다?

#### 월간윤종신
나만의 소프트웨어도 월(년)마다 내도록 계획하고만 있다

-----------------------------------------------------------------------

## software

#### twelve factor app
웹앱처럼 서비스로 사용되는 소프트웨어에서 이 요구사항 12가지를 챙겨서 만들자는
방법론
- https://12factor.net/ko/

1. 버전 컨트롤을 사용하자
2. 라이브러리 의존성을 명시적으로 선언하고 분리하자
3. 인증 정보, DB 설정, 각종 배포 설정을 환경 변수로 관리하자
4. 객체 저장소, DB, 캐시, 메시지 큐, 외부 API 서버 등을 구별 없이 서비스로 인식하자
5. 애플리케이션 빌드, 출시, 실행 단계를 엄격하게 분리하고 관리하자
6. 애플리케이션을 독립적인 무상태(stateless) 프로세스로 실행하자 (DB 사용. 로컬 Disk 사용 X)
7. 독립적인 포트를 바인딩하여 서비스로 공개하고 포트로 들어오는 요청을 처리하자
8. 이러한 프로세스 모델을 기반으로 수직적, 수평적 확장을 제공하자
9. 빠른 시작과 그레이스풀 셧다운을 통한 안정성 극대화를 하자
10. 개발, 테스트 및 정식 서비스 환경을 최대한 동일하게 유지하자
11. 각종 로그는 파일로 다루지 않고 앱이 실행되는 도중에 실시간으로 포착하자
12. 관리자 업무와 백 오피스 업무는 기존 애플리케이션 같은 환경에서 동일 형태로 취급하자

그리고 추가로 3가지를 더 고려하면 좋겠다고 이야기했다고 한다
텔레메트리(모니터링), 자동화, 보안

#### 서버리스
이벤트 소스 -> 함수 -> 서비스

#### 데이터베이스 정규화
검색이 쉽도록 정규화를 하는 방식이 정리되어있는 컨벤션이 있다
